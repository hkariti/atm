. = torg + 1000

main:
        mov pc, sp              ; init the stack and all global variables
        tst -(sp)
        mov #-1, MovesScore     ; reset MovesScore & MovesShort
        mov #-1, MovesShort

        jsr pc, checkBoard      ; check if Board is valid
        cmp r4, #0              
        bne mainReturn          ; exit program if Board is invalid

        mov #MovesShort, -(sp)  ; push findShortest args to stack
        mov numMoves, -(sp)
        jsr pc, findShortest    ; call findShortest
        add #4, sp              ; restore stack pointer

        mov #MovesScore, -(sp)  ; push findScore args to stack
        mov numMoves, -(sp)
        jsr pc, findScore       ; call findScore
        add #4, sp              ; restore stack pointer

mainReturn:
        halt

; Link register: pc
; Arguments: r4 - source move array
;            r3 - dest move array
copyMovesArray:
        mov r0, -(sp)           ; save non-volatile register r0
        mov r3, -(sp)           ; save non-volatile register r3
        mov r4, -(sp)           ; save non-volatile register r4
        clr r0
cpyMovesLoop:
        movb (r4), r0          
        movb (r4)+, (r3)+       ; move current source move to dest
        cmp r0, #'@             ; iterate through loop while last move is not last '@
        bne cpyMovesLoop        
        mov (sp)+, r4           ; restore non-volatile register r4
        mov (sp)+, r3           ; restore non-volatile register r3
        mov (sp)+, r0           ; restore non-volatile register r0
        rts pc


; Link register: pc
; Arguments: r4 - moves array to add moves to, doesnt changed during runtime
;            r0 - move number to add
changeLastMove:
        mov r4, -(sp)           ; save non-volatile register r4
        mov r1, -(sp)           ; save non-volatile register r1
chgLstMovLoop:
        movb (r4)+, r1          ; iterate until got to last move
        cmp r1, #'@
        bne chgLstMovLoop
        sub #2, r4              ; go one move before, and save r0 into it 
        movb r0, (r4)
        mov (sp)+, r1           ; restore non-volatile r0
        mov (sp)+, r4           ; restore non-volatile r0
        rts pc        

; Link register: pc
; Params:       r1 - Move
; Return:       r2 - Target slot value if move was legal, -1 if illegal
movePlayer:
        mov r0, -(sp)           ; save registers
        mov r1, -(sp)
MPLoop:                         ; a loop which forwards the player 
                                ; the same amount of steps
                                ; as the move dictates
        cmp r1, #0              ; if we finished forwarding the player
        beq getNextStartingPos
        dec r1                  ; r1 holds how many steps left to forward, 
                                ; so it gets decreased by one
                                ; each time we move it one step 
        mov currentY, r0
        asr r0
        bcs moveRight           ; check if current row is even
                                ; if it's even we move the player left
                                ; and if odd we move it to the right
moveLeft:
        cmp currentX, #1        ; check if we are at the first column
        beq moveUp              ; then we need to move it up
        dec currentX            ; if not - just move it one step to the left
        jmp MPLoop
moveRight:
        cmp currentX, nCols     ; check if we are at the last column
        beq moveUp              ; then we need to move it up
        inc currentX            ; if not - just move is one step to the right
        jmp MPLoop
moveUp:
        cmp currentY, nRows     ; check if we are already at the last row
        beq MPError             ; if so - we exceeded the finish position 
                                ; and raise error
        inc currentY            ; if not - just move it step upwords
        jmp MPLoop
getNextStartingPosition:        ; check where the player is at 
                                ; and act accordingly

        mov currentX, -(sp)
        mov currentY, -(sp)
        jsr pc, getCurrentBoardItem
        add #4, sp
checkCurrentBoardItem:
        cmp r0, #'L             ; if the player is on a ladder
        beq onLadder            
        cmp r0, #'S             ; if the player is on a snake
        bne doneMove
onSnake:
        cmp currentY, #1        ; check if the player is on the first row
        beq MPError             ; if so - we cannot go further down, 
                                ; raise exception
        dec currentY            ; if not - decrease current row value
        br getNextStartingPosition      ; check again where the player 
                                        ; is at and act accordingly
onLadder:
        cmp currentY, nRows     ; check if the player is on the last row
        beq MPError             ; if so - we cannot go further up, raise exception
        inc currentY            ; if not - increase current row value
        br getNextStartingPosition      ; check again where the player is at 
                                        ; and act accordingly
doneMove:                       ; the player finished executing the move, 
                                ; and now he is at a numbered square 
                                ; (not ladder nor snake).
                                ; r0 holds the current square value
        mov r0, r2              ; Return the current value
        jmp MPEpilogue
MPError:
        mov #-1, r2
MPEpilogue:
        mov (sp)+, r0
        mov (sp)+, r1
        rts pc

; currentX & currentY are only used by movePlayer func, so it will be much more readable
; currentX and currentY are used to describe the current player position.
; currentX describe the current Column, and currentY current Row
; both values ranges from 1 to nCols/nRows, 
; while the first position the player begins
; at is [1,1] and the last ending position is [nCols, nRows]
currentX: .word 0
currentY: .word 1



; Link register: pc
; Params:       2(sp) - currentY
;               4(sp) - currentX
; Return:       r0 - Board item at [currentX, currentY]
getCurrentBoardItem:            
        mov r1, -(sp)

        mov nRows, r0     
        sub 4(sp), r0           ; r0 now holds [nRows - currentY]
        mul nCols, r0           ; r1 now holds the the board index to the beginning of the current row
        add 6(sp), r1        
        dec r1                  ; r1 now holds the board index to the current position
        movb Board(r1), r0      ; r0 now holds the board value at r1 index

        mov (sp)+, r1
        rts pc

; Link register: pc
; Params:       2(sp) - currentY
;               4(sp) - currentX
; Return:       r0 - 0 if current is final square or 1 otherwise
isAtLastPosition:
        mov 2(sp), r0
        cmp 2(sp), nRows        ; check if currentY is at top row
        bne notLastPosition
        mov 2(sp), r0
        asr r0
        bcs mostRightColCheck   ; check if top row is even
mostLeftColCheck:               ; If we are at even row, 
                                ; we finish at the most right square
        cmp 4(sp), #1        
        bne notLastPosition
        jmp atLastPosition
mostRightColCheck:              ; else - we finish at the most left square
        cmp 4(sp), nCols
        beq atLastPosition
notLastPosition:
        mov #1, r0
        rts pc
atLastPosition:
        mov #0, r0
        rts pc



