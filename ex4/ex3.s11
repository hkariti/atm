. = torg + 1000

main:
        mov pc, sp              ; init the stack and all global variables
        tst -(sp)
        mov #-1, MovesScore     ; reset MovesScore & MovesShort
        mov #-1, MovesShort

        jsr pc, checkBoard      ; check if Board is valid
        cmp r4, #0              
        bne mainReturn          ; exit program if Board is invalid

        mov #MovesShort, -(sp)  ; push findShortest args to stack
        mov numMoves, -(sp)
        jsr pc, findShortest    ; call findShortest
        add #4, sp              ; restore stack pointer

        mov #MovesScore, -(sp)  ; push findScore args to stack
        mov numMoves, -(sp)
        jsr pc, findScore       ; call findScore
        add #4, sp              ; restore stack pointer

mainReturn:
        halt

; Link register: pc
; Arguments: r4 - source move array
;            r3 - dest move array
copyMovesArray:
        mov r0, -(sp)           ; save non-volatile register r0
        mov r3, -(sp)           ; save non-volatile register r3
        mov r4, -(sp)           ; save non-volatile register r4
        clr r0
cpyMovesLoop:
        movb (r4), r0          
        movb (r4)+, (r3)+       ; move current source move to dest
        cmp r0, #'@             ; iterate through loop while last move is not last '@
        bne cpyMovesLoop        
        mov (sp)+, r4           ; restore non-volatile register r4
        mov (sp)+, r3           ; restore non-volatile register r3
        mov (sp)+, r0           ; restore non-volatile register r0
        rts pc


; Link register: pc
; Arguments: r4 - moves array to add moves to, doesnt changed during runtime
;            r0 - move number to add
changeLastMove:
        mov r4, -(sp)           ; save non-volatile register r4
        mov r1, -(sp)           ; save non-volatile register r1
chgLstMovLoop:
        movb (r4)+, r1          ; iterate until got to last move
        cmp r1, #'@
        bne chgLstMovLoop
        sub #2, r4              ; go one move before, and save r0 into it 
        movb r0, (r4)
        mov (sp)+, r1           ; restore non-volatile r0
        mov (sp)+, r4           ; restore non-volatile r0
        rts pc        

; Link register: pc
; Params:       r4 - pointer to Moves array, doesnt changed during run
; Return:       r2 - Output
;               r3 - Score
solveGame:   
        mov r0, -(sp)
        mov r1, -(sp)
        mov r4, -(sp)


        mov #1, currentX        ; we start at position [1,1] (see below for 
                                ; current position explanation)
        mov #1, currentY        
        clr r3
        
mainLoopStart:                  ; The main loop which iterates through 
                                ; all Moves and execute them
        movb (r4)+, r1          ; r1 holds current Move value 
                                ; (how many steps to forward)
        cmp r1, #'@             ; if we got to the end of Moves array
        beq finishedAllMoves    

movePlayer:                     ; a loop which forwards the player 
                                ; the same amount of steps
                                ; as pointed in Moves array
        cmp r1, #0              ; if we finished forwarding the player
        beq getNextStartingPos
        dec r1                  ; r1 holds how many steps left to forward, 
                                ; so it gets decreased by one
                                ; each time we move it one step 
        mov currentY, r0
        asr r0
        bcs moveRight           ; check if current row is even
                                ; if it's even we move the player left
                                ; and if odd we move it to the right
moveLeft:
        cmp currentX, #1        ; check if we are at the first column
        beq moveUp              ; then we need to move it up
        dec currentX            ; if not - just move it one step to the left
        jmp movePlayer
moveRight:
        cmp currentX, nCols     ; check if we are at the last column
        beq moveUp              ; then we need to move it up
        inc currentX            ; if not - just move is one step to the right
        jmp movePlayer
moveUp:
        cmp currentY, nRows     ; check if we are already at the last row
        beq errorPastLimit      ; if so - we exceeded the finish position 
                                ; and raise error
        inc currentY            ; if not - just move it step upwords
        jmp movePlayer
errorPastLimit:                 ; raise error - we already passed the finish line
        mov #'F, r2         
        mov #2, r3
        jmp slvGameEpilogue
getNextStartingPosition:        ; check where the player is at 
                                ; and act accordingly

        mov currentX, -(sp)
        mov currentY, -(sp)
        jsr pc, getCurrentBoardItem
        add #4, sp
checkCurrentBoardItem:
        cmp r0, #'L             ; if the player is on a ladder
        beq onLadder            
        cmp r0, #'S             ; if the player is on a snake
        bne doneMove
onSnake:
        cmp currentY, #1        ; check if the player is on the first row
        beq errorSnakeAtBottom  ; if so - we cannot go further down, 
                                ; raise exception
        dec currentY            ; if not - decrease current row value
        br getNextStartingPosition      ; check again where the player 
                                        ; is at and act accordingly
onLadder:
        cmp currentY, nRows     ; check if the player is on the last row
        beq errorLadderAtTop    ; if so - we cannot go further up, raise exception
        inc currentY            ; if not - increase current row value
        br getNextStartingPosition      ; check again where the player is at 
                                        ; and act accordingly
errorSnakeAtBottom:             ; raise error - player got a snake on first row
        mov #'F, r2
        mov #0, r3
        jmp slvGameEpilogue
errorLadderAtTop:               ; raise error - player got a ladder on top floor
        mov #'F, r2 
        mov #1, r3
        jmp slvGameEpilogue

doneMove:                       ; the player finished executing the move, 
                                ; and now he is at a numbered square 
                                ; (not ladder nor snake).
                                ; r0 holds the current square value
        add r0, r3              ; add the current number to score
        jmp mainLoopStart       ; fetch another move and execute it!


finishedAllMoves:               ; we got here when the player finished 
                                ; executing all moves
                                ; check if the current position is 
                                ; the last position, if not - the player didn't 
                                ; accomplish the game ): raise exception
        mov currentX, -(sp)
        mov currentY, -(sp)
        jsr pc, isAtLastPosition
        add #4, sp
        cmp r0, 0
        bne errorFinishedAtWrongPlace
        
finishSuccess:                  ; the player ACCOMPLISHED THE GAME (: !! 
                                ; return success!
        mov #'S, r2
        jmp slvGameEpilogue

errorFinishedAtWrongPlace:      ; raise error - the player didn't finish 
                                ; at the last square
        mov #'F, r2
        mov #3, r3
        jmp slvGameEpilogue

slvGameEpilogue:
        mov (sp)+, r4
        mov (sp)+, r1
        mov (sp)+, r0
        rts pc

; currentX & currentY are only used by solveGame func, so it will be much more readable
; currentX and currentY are used to describe the current player position.
; currentX describe the current Column, and currentY current Row
; both values ranges from 1 to nCols/nRows, 
; while the first position the player begins
; at is [1,1] and the last ending position is [nCols, nRows]
currentX: .word 0
currentY: .word 1



; Link register: pc
; Params:       2(sp) - currentY
;               4(sp) - currentX
; Return:       r0 - Board item at [currentX, currentY]
getCurrentBoardItem:            
        mov r1, -(sp)

        mov nRows, r0     
        sub 4(sp), r0           ; r0 now holds [nRows - currentY]
        mul nCols, r0           ; r1 now holds the the board index to the beginning of the current row
        add 6(sp), r1        
        dec r1                  ; r1 now holds the board index to the current position
        movb Board(r1), r0      ; r0 now holds the board value at r1 index

        mov (sp)+, r1
        rts pc


; Link register: pc
; Params:       2(sp) - currentY
;               4(sp) - currentX
; Return:       r0 - 0 if current is final square or 1 otherwise
isAtLastPosition:
        mov 2(sp), r0
        cmp 2(sp), nRows        ; check if currentY is at top row
        bne notLastPosition
        mov 2(sp), r0
        asr r0
        bcs mostRightColCheck   ; check if top row is even
mostLeftColCheck:               ; If we are at even row, 
                                ; we finish at the most right square
        cmp 4(sp), #1        
        bne notLastPosition
        jmp atLastPosition
mostRightColCheck:              ; else - we finish at the most left square
        cmp 4(sp), nCols
        beq atLastPosition
notLastPosition:
        mov #1, r0
        rts pc
atLastPosition:
        mov #0, r0
        rts pc



